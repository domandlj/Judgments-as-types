<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Judgments As Types</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: #F5F5F5;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Judgments As Types</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#implementing-formal-systems-in-idris"
id="toc-implementing-formal-systems-in-idris">Implementing formal
systems in Idris</a>
<ul>
<li><a href="#curry-howard" id="toc-curry-howard">Curry-Howard</a></li>
<li><a href="#translations" id="toc-translations">Translations</a></li>
</ul></li>
<li><a href="#propositional-classical-logic"
id="toc-propositional-classical-logic">Propositional (classical)
logic</a>
<ul>
<li><a href="#syntax" id="toc-syntax">Syntax</a></li>
<li><a href="#set-of-proofs" id="toc-set-of-proofs">Set of
proofs</a></li>
<li><a href="#proofs-examples" id="toc-proofs-examples">Proofs
examples</a></li>
</ul></li>
<li><a href="#first-order-logic" id="toc-first-order-logic">First order
logic</a>
<ul>
<li><a href="#syntax-1" id="toc-syntax-1">Syntax</a></li>
<li><a href="#set-of-proofs-1" id="toc-set-of-proofs-1">Set of
proofs</a></li>
<li><a href="#proofs-examples-1" id="toc-proofs-examples-1">Proofs
examples</a></li>
</ul></li>
<li><a href="#whats-the-point-of-this-should-i-use-agda-or-idris"
id="toc-whats-the-point-of-this-should-i-use-agda-or-idris">Whats the
point of this? Should i use Agda or Idris?</a></li>
<li><a href="#code" id="toc-code">Code</a></li>
<li><a href="#bibliography" id="toc-bibliography">Bibliography</a></li>
</ul>
</nav>
<h1 id="implementing-formal-systems-in-idris">Implementing formal
systems in Idris</h1>
<p>You can use a dependently typed language like Idris, Agda, Coq
(gallina?), etc. as a metalangue for reasoning about formal systems
(propositional logic, FOL, hoare logic, simply typed lambda calculus,
etc.) encoding the judgments in types.<br />
This idea is the core of the Edinburgh Logical Framework (ELF).</p>
<p>I will show how to implement classical propositional logic and first
order logic, with a fast, easy and painless way to handle binders.<br />
Perhaps later i add Hoare logic.</p>
<h2 id="curry-howard">Curry-Howard</h2>
<table>
<colgroup>
<col style="width: 38%" />
<col style="width: 24%" />
<col style="width: 37%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Formal system</strong></th>
<th><strong>Type theory</strong></th>
<th><strong>Marketing name</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>theorem (formula)</td>
<td>type</td>
<td><em>propositions-as-types</em></td>
</tr>
<tr class="even">
<td>proof</td>
<td>term</td>
<td><em>proofs-as-programs</em></td>
</tr>
<tr class="odd">
<td>judgment (inference rule)</td>
<td>type</td>
<td><em>judgments-as-types</em></td>
</tr>
</tbody>
</table>
<h2 id="translations">Translations</h2>
<p>Here’s a refreshers of the CH correspondence, i will use Idris, but
Agda is really alike.</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 22%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Intuitionistic logic</strong></th>
<th><strong>Type theory</strong></th>
<th><strong>Idris</strong></th>
<th><strong>Agda</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(\top\)</span></td>
<td><span class="math inline">\(1\)</span></td>
<td><code>()</code></td>
<td><code>⊤</code></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\bot\)</span></td>
<td><span class="math inline">\(0\)</span></td>
<td><code>Void</code></td>
<td><code>⊥</code></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\phi \Rightarrow \psi\)</span></td>
<td><span class="math inline">\(\phi \rightarrow \psi\)</span></td>
<td><code>ϕ -&gt; Ψ</code></td>
<td><code>ϕ → Ψ</code></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\neg \phi\)</span></td>
<td><span class="math inline">\(\phi \rightarrow 0\)</span></td>
<td><code>ϕ -&gt; Void</code></td>
<td><code>ϕ → ⊥</code></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\phi \wedge \psi\)</span></td>
<td><span class="math inline">\(\phi \times \psi\)</span></td>
<td><code>(ϕ , Ψ)</code></td>
<td><code>ϕ × Ψ</code></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\phi \vee \psi\)</span></td>
<td><span class="math inline">\(\phi + \psi\)</span></td>
<td><code>Either ϕ Ψ</code></td>
<td><code>Either ϕ Ψ</code></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\forall x\in\phi.\psi(x)\)</span></td>
<td><span class="math inline">\(\Pi x:\phi. \psi(x)\)</span></td>
<td><code>(x:ϕ) -&gt; Ψ x</code></td>
<td><code>(x:ϕ) → Ψ x</code></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\exists x\in\phi.\psi(x)\)</span></td>
<td><span class="math inline">\(\Sigma x:\phi.\psi(x)\)</span></td>
<td><code>(x:ϕ ** Ψ x)</code></td>
<td><code>Σ ϕ (λx → Ψ x)</code></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(=\)</span></td>
<td><span class="math inline">\(=\)</span></td>
<td><code>=</code></td>
<td><code>≡</code></td>
</tr>
</tbody>
</table>
<h1 id="propositional-classical-logic">Propositional (classical)
logic</h1>
<h3 id="syntax">Syntax</h3>
<p><span class="math display">\[
e \ ::= \ \neg e \ | \  e \Rightarrow e \ | \ e \wedge e
\]</span></p>
<p>In idris is</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode idris"><code class="sourceCode idris"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Formula</span> <span class="ot">:</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Neg</span> <span class="ot">:</span> <span class="dt">Formula</span> <span class="ot">-&gt;</span> <span class="dt">Formula</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Imp</span> <span class="ot">:</span> <span class="dt">Formula</span> <span class="ot">-&gt;</span> <span class="dt">Formula</span> <span class="ot">-&gt;</span> <span class="dt">Formula</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">And</span> <span class="ot">:</span> <span class="dt">Formula</span> <span class="ot">-&gt;</span> <span class="dt">Formula</span> <span class="ot">-&gt;</span> <span class="dt">Formula</span></span></code></pre></div>
<h3 id="set-of-proofs">Set of proofs</h3>
<p>We define that the set of proofs of a formula <span
class="math inline">\(T(\phi) =\)</span> { proof | proof of <span
class="math inline">\(\phi\)</span> } is inductively constructed by
judgments.</p>
<p>In idris we can define it with the following dependent type:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode idris"><code class="sourceCode idris"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">T</span> <span class="ot">:</span> <span class="dt">Formula</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a> <span class="co">-- The constructors of this type are the judgments of natural deduction  </span></span></code></pre></div>
<p>Note that <span class="math inline">\(t\)</span> is a proof of <span
class="math inline">\(\phi\)</span> if <span class="math inline">\(t \in
T(\phi)\)</span> or, using Curry-Howard and Idris notation, if t : T
ϕ</p>
<p>Lets define the judgments as constructors of the type T<br />
<span class="math inline">\(\phi\)</span><br />
▁ ( <span class="math inline">\(Ident\)</span> )<br />
<span class="math inline">\(\phi\)</span></p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode idris"><code class="sourceCode idris"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Ident</span> <span class="ot">:</span> <span class="dt">T</span> ϕ <span class="ot">-&gt;</span> <span class="dt">T</span> ϕ</span></code></pre></div>
<hr />
<p><span class="math inline">\([\phi]\)</span><br />
⋮<br />
<span class="math inline">\(\psi\)</span><br />
─── ( <span class="math inline">\(ImpI\)</span> )<br />
<span class="math inline">\(\phi \Rightarrow \psi\)</span></p>
<p> </p>
<p><span class="math inline">\(\phi \Rightarrow \psi \ \ \ \ \ \
\phi\)</span><br />
────── ( <span class="math inline">\(ImpE\)</span> )<br />
<span class="math inline">\(\psi\)</span></p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode idris"><code class="sourceCode idris"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ImpI</span> <span class="ot">:</span> (<span class="dt">T</span> ϕ <span class="ot">-&gt;</span> <span class="dt">T</span> Ψ) <span class="ot">-&gt;</span> <span class="dt">T</span> (ϕ <span class="fu">`Imp`</span> Ψ)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ImpE</span> <span class="ot">:</span> <span class="dt">T</span> (ϕ <span class="fu">`Imp`</span> Ψ) <span class="ot">-&gt;</span> <span class="dt">T</span> ϕ <span class="ot">-&gt;</span> <span class="dt">T</span> Ψ</span></code></pre></div>
<hr />
<p><span class="math inline">\(\phi \ \ \ \ \ \ \psi\)</span><br />
──── ( <span class="math inline">\(AndI\)</span> )<br />
<span class="math inline">\(\phi \wedge \psi\)</span></p>
<p> </p>
<p><span class="math inline">\(\phi \wedge \psi\)</span><br />
──── ( <span class="math inline">\(AndE1\)</span> )<br />
<span class="math inline">\(\phi\)</span></p>
<p> </p>
<p><span class="math inline">\(\phi \wedge \psi\)</span><br />
──── ( <span class="math inline">\(AndE2\)</span> )<br />
<span class="math inline">\(\psi\)</span></p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode idris"><code class="sourceCode idris"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">AndI</span> <span class="ot">:</span> <span class="dt">T</span> ϕ <span class="ot">-&gt;</span> <span class="dt">T</span> Ψ <span class="ot">-&gt;</span> <span class="dt">T</span> (ϕ <span class="fu">`And`</span> Ψ)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">AndE1</span> <span class="ot">:</span> <span class="dt">T</span> (ϕ <span class="fu">`And`</span> Ψ) <span class="ot">-&gt;</span> <span class="dt">T</span> ϕ</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>       </span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">AndE2</span> <span class="ot">:</span> <span class="dt">T</span> (ϕ <span class="fu">`And`</span> Ψ) <span class="ot">-&gt;</span> <span class="dt">T</span> Ψ</span></code></pre></div>
<hr />
<p><span class="math inline">\([\phi] \ \ \ \  [\phi]\)</span><br />
<span class="math inline">\(⋮ \ \ \ \ \ \ \ \ \ \  ⋮\)</span><br />
<span class="math inline">\(\psi \ \ \ \ \ \ \ \neg \psi\)</span><br />
──── ( <span class="math inline">\(NegI\)</span> )<br />
<span class="math inline">\(\neg \phi\)</span></p>
<p> </p>
<p><span class="math inline">\(\neg \neg \phi\)</span><br />
── ( <span class="math inline">\(NegI\)</span> )<br />
<span class="math inline">\(\phi\)</span></p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode idris"><code class="sourceCode idris"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">NegI</span> <span class="ot">:</span> (<span class="dt">T</span> ϕ <span class="ot">-&gt;</span> <span class="dt">T</span> Ψ) <span class="ot">-&gt;</span> (<span class="dt">T</span> ϕ <span class="ot">-&gt;</span> <span class="dt">T</span> (<span class="dt">Neg</span> Ψ)) <span class="ot">-&gt;</span> <span class="dt">T</span> (<span class="dt">Neg</span> ϕ)  </span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">NegE</span> <span class="ot">:</span> <span class="dt">T</span> (<span class="dt">Neg</span> <span class="fu">$</span> <span class="dt">Neg</span> ϕ) <span class="ot">-&gt;</span> <span class="dt">T</span> ϕ</span></code></pre></div>
<p>The (NegE) is equivalent to the law of excluded middle, which in
intuitionistic logic is illegal. The (NegI) is proof of negation which
is legal in intuitionistic logic. <a
href="http://math.andrej.com/2010/03/29/proof-of-negation-and-proof-by-contradiction/">See</a>.</p>
<h3 id="proofs-examples">Proofs examples</h3>
<p>Lets prove <span class="math inline">\((P \Rightarrow P)\)</span>,
<span class="math inline">\((P \wedge Q \Rightarrow P)\)</span> and
<span class="math inline">\((P \wedge Q \Rightarrow Q)\)</span></p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode idris"><code class="sourceCode idris"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="dt">P</span>, <span class="dt">Q</span>, <span class="dt">R</span> <span class="ot">:</span> <span class="dt">Formula</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="fu">proof1</span> <span class="ot">:</span> <span class="dt">T</span> (<span class="dt">P</span> <span class="fu">`Imp`</span> <span class="dt">P</span>)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>proof1 <span class="fu">=</span> <span class="dt">ImpI</span> <span class="dt">Ident</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="fu">proof2</span> <span class="ot">:</span> <span class="dt">T</span> ((<span class="dt">P</span> <span class="fu">`And`</span> <span class="dt">Q</span>) <span class="fu">`Imp`</span> <span class="dt">P</span>)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>proof2 <span class="fu">=</span> <span class="dt">ImpI</span> <span class="dt">AndE1</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="fu">proof3</span> <span class="ot">:</span> <span class="dt">T</span> ((<span class="dt">P</span> <span class="fu">`And`</span> <span class="dt">Q</span>) <span class="fu">`Imp`</span> <span class="dt">Q</span>)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>proof3 <span class="fu">=</span> <span class="dt">ImpI</span> <span class="dt">AndE2</span></span></code></pre></div>
<p>For better understanding draw the natural deduction proof tree, the
judgments names that are used are<br />
what you see in the terms (proofs) <code>proof1</code>,
<code>proof2</code> and <code>proof3</code>.  </p>
<p>Notice something, we are proving using dependent type theory as a
metalanguage (propositional classical logic is the object
language).<br />
It’s not the same as proving using directly Curry-Howard. This would be
the proofs using just Curry-Howard, notice the difference.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode idris"><code class="sourceCode idris"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">proof1</span> <span class="ot">:</span> { <span class="dt">P</span> <span class="ot">:</span> <span class="dt">Type</span> } <span class="ot">-&gt;</span> <span class="dt">P</span> <span class="ot">-&gt;</span> <span class="dt">P</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>proof1 p <span class="fu">=</span> p</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="fu">proof2</span> <span class="ot">:</span> { <span class="dt">P</span> , <span class="dt">Q</span> <span class="ot">:</span> <span class="dt">Type</span> } <span class="ot">-&gt;</span> (<span class="dt">P</span>, <span class="dt">Q</span>) <span class="ot">-&gt;</span> <span class="dt">P</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>proof2 (a, b) <span class="fu">=</span> a</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="fu">proof3</span> <span class="ot">:</span> { <span class="dt">P</span>, <span class="dt">Q</span> <span class="ot">:</span> <span class="dt">Type</span> } <span class="ot">-&gt;</span> (<span class="dt">P</span>, <span class="dt">Q</span>) <span class="ot">-&gt;</span> <span class="dt">Q</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>proof3 (a, b) <span class="fu">=</span> b</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
<p>The types here corresponds to formulas of an intuitionistic higer
order logic.</p>
<h1 id="first-order-logic">First order logic</h1>
<p>In propositional logic there are no variable binders, but in formal
systems suchs as FOL or lambda calculus we have binders.<br />
With binders and substitution we have the problem of capture, we have to
think about fresh variables, etc. when writing in paper is not as much
of a problem but when we want to mechanize it with a computer we are
challenged.<br />
One common solution, in lambda calculus, is to forget of named variables
and use de Bruijn indexes or levels.</p>
<p>The solutions that we will use here is really fast to implement and
is easier, we will exploit the fact that the metalanguage (idris or the
type theory behind it) has binders, and we will use it in the following
way.</p>
<p>Suppose in a formula <span class="math inline">\(\phi\)</span> of the
object language (FOL in this case) we want to substitute the variable
<span class="math inline">\(v\)</span> for the expression <span
class="math inline">\(e\)</span>, i.e., <span class="math inline">\(\phi
[v := e ]\)</span>, we can define it in the following abstraction in the
metalanguage <span class="math inline">\((\psi \ e)\)</span> where <span
class="math inline">\(\psi = (\lambda v . \phi \ v)\)</span>, we let the
<span class="math inline">\(\beta\)</span>-reduction take care of the
substitution.</p>
<h3 id="syntax-1">Syntax</h3>
<p><span class="math inline">\(e \ ::= t \ | \ \neg e \ | \  e
\Rightarrow e \ | \ e \wedge e \ | \ \forall v . e \ | \ \exists v . e |
\ \epsilon v . e\)</span><br />
<span class="math inline">\(t \ ::= v \ | \  t = t\)</span><br />
<span class="math inline">\(v \ ::= x, y, z, ...\)</span></p>
<p>We are using a not so common presentation of FOL with <span
class="math inline">\(\epsilon\)</span> the Hilbert Choice operator, we
can think of this operator in this way: if <span
class="math inline">\((\exists x . \phi)\)</span> holds then the we can
find a witness <span class="math inline">\(w = \epsilon (\exists x .
\phi)\)</span> such that <span class="math inline">\(\phi(w)\)</span>
holds.<br />
This binder is at the terms levels of syntax, <span
class="math inline">\(\forall, \exists\)</span> at the formula
levels.</p>
<p>This abstract syntax is represented a in Idris as follows,</p>
<p>At the level of variables, we let them range over an index, like
<span class="math inline">\(v \in Index\)</span></p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode idris"><code class="sourceCode idris"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Index</span> <span class="ot">:</span> <span class="dt">Type</span></span></code></pre></div>
<p>For all formulas, except choice:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode idris"><code class="sourceCode idris"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Formula</span> <span class="ot">:</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Propositional connectives</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Neg</span> <span class="ot">:</span> <span class="dt">Formula</span> <span class="ot">-&gt;</span> <span class="dt">Formula</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Imp</span> <span class="ot">:</span> <span class="dt">Formula</span> <span class="ot">-&gt;</span> <span class="dt">Formula</span> <span class="ot">-&gt;</span> <span class="dt">Formula</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">And</span> <span class="ot">:</span> <span class="dt">Formula</span> <span class="ot">-&gt;</span> <span class="dt">Formula</span> <span class="ot">-&gt;</span> <span class="dt">Formula</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Equal</span> <span class="ot">:</span> <span class="dt">Index</span> <span class="ot">-&gt;</span> <span class="dt">Index</span> <span class="ot">-&gt;</span> <span class="dt">Formula</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- The first order binders</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Forall</span> <span class="ot">:</span> (<span class="dt">Index</span> <span class="ot">-&gt;</span> <span class="dt">Formula</span>) <span class="ot">-&gt;</span> <span class="dt">Formula</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Exists</span> <span class="ot">:</span> (<span class="dt">Index</span> <span class="ot">-&gt;</span> <span class="dt">Formula</span>) <span class="ot">-&gt;</span> <span class="dt">Formula</span></span></code></pre></div>
<p>As for <span class="math inline">\(\epsilon\)</span> we have it this
way, outside the <code>Formula</code> type,</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode idris"><code class="sourceCode idris"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Choice</span> <span class="ot">:</span> (<span class="dt">Index</span> <span class="ot">-&gt;</span> <span class="dt">Formula</span>) <span class="ot">-&gt;</span> <span class="dt">Index</span></span></code></pre></div>
<p>Examples<br />
<span class="math inline">\((\forall x . x = x)\)</span>, <span
class="math inline">\((\exists x . x = x)\)</span> and <span
class="math inline">\(\epsilon (x=x)\)</span></p>
<p>Are</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode idris"><code class="sourceCode idris"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Forall</span> (<span class="fu">\</span>x <span class="ot">=&gt;</span> x <span class="fu">`Equal`</span> x) <span class="ot">:</span> <span class="dt">Formula</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Exists</span> (<span class="fu">\</span>x <span class="ot">=&gt;</span> x <span class="fu">`Equal`</span> x) <span class="ot">:</span> <span class="dt">Formula</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Choice</span> (<span class="fu">\</span>x <span class="ot">=&gt;</span> x <span class="fu">`Equal`</span> x) <span class="ot">:</span> <span class="dt">Index</span></span></code></pre></div>
<p>In this way we do not have to worry about <span
class="math inline">\(\alpha\)</span>-conversions because the
metalanguage takes it care already. For instance,</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode idris"><code class="sourceCode idris"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Forall</span> (<span class="fu">\</span>x <span class="ot">=&gt;</span> x <span class="fu">`Equal`</span> x)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Forall</span> (<span class="fu">\</span>z <span class="ot">=&gt;</span> z <span class="fu">`Equal`</span> z)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Forall</span> (<span class="fu">\</span>🍉 <span class="ot">=&gt;</span> 🍉 <span class="fu">`Equal`</span> 🍉)</span></code></pre></div>
<p>Are all <span class="math inline">\(\alpha\)</span> equivalent.</p>
<h3 id="set-of-proofs-1">Set of proofs</h3>
<p>Again we define the set of proofs of a formula <span
class="math inline">\(T(\phi)\)</span> as the following dependent
type</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode idris"><code class="sourceCode idris"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">T</span> <span class="ot">:</span> <span class="dt">Formula</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a> <span class="co">-- The constructors of this type are all of the propositional logic case and the following new ones</span></span></code></pre></div>
<p>── ( <span class="math inline">\(Equal0\)</span> )<br />
<span class="math inline">\(x=x\)</span></p>
<p> </p>
<p><span class="math inline">\(x=y\)</span><br />
──── ( <span class="math inline">\(Equal1\)</span> )<br />
<span class="math inline">\(t(x)=t(y)\)</span></p>
<p> </p>
<p><span class="math inline">\(x=y \ \ \ \ \phi(x)\)</span><br />
───── ( <span class="math inline">\(Equal2\)</span> )<br />
<span class="math inline">\(\phi(y)\)</span></p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode idris"><code class="sourceCode idris"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Equal0</span> <span class="ot">:</span> {x <span class="ot">:</span> <span class="dt">Index</span>} <span class="ot">-&gt;</span> <span class="dt">T</span> (x <span class="fu">`Equal`</span> x) </span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Equal1</span> <span class="ot">:</span> {t <span class="ot">:</span> <span class="dt">Index</span><span class="ot">-&gt;</span> <span class="dt">Index</span>} <span class="ot">-&gt;</span> <span class="dt">T</span> (x <span class="fu">`Equal`</span> y) <span class="ot">-&gt;</span> <span class="dt">T</span> ((t x) <span class="fu">`Equal`</span> (t y))</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Equal2</span> <span class="ot">:</span> {ϕ <span class="ot">:</span> <span class="dt">Index</span> <span class="ot">-&gt;</span> <span class="dt">Formula</span>} <span class="ot">-&gt;</span> <span class="dt">T</span> (x <span class="fu">`Equal`</span> y) <span class="ot">-&gt;</span> <span class="dt">T</span> (ϕ x) <span class="ot">-&gt;</span> <span class="dt">T</span> (ϕ y)</span></code></pre></div>
<hr />
<p><span class="math inline">\(\exists x . \phi\)</span><br />
──── ( <span class="math inline">\(ChoiceI\)</span> )<br />
<span class="math inline">\(\phi (\epsilon \phi)\)</span></p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode idris"><code class="sourceCode idris"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ChoiceI</span> <span class="ot">:</span> {ϕ <span class="ot">:</span> <span class="dt">Index</span> <span class="ot">-&gt;</span> <span class="dt">Formula</span>} <span class="ot">-&gt;</span> <span class="dt">T</span> (<span class="dt">Exists</span> ϕ) <span class="ot">-&gt;</span> <span class="dt">T</span> (ϕ (<span class="dt">Choice</span> ϕ))  </span></code></pre></div>
<hr />
<p><span class="math inline">\(\ \ \ \ \ \ \ \ \ \ \ [\exists x .
\phi]\)</span><br />
<span class="math inline">\(\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
⋮\)</span><br />
<span class="math inline">\(\exists x. \phi \ \ \ \ \ \ \
\psi\)</span><br />
───── ( <span class="math inline">\(ExistsE\)</span> )<br />
<span class="math inline">\(\ \ \ \psi\)</span></p>
<p> </p>
<p><span class="math inline">\(\ \ \phi \ t\)</span></p>
<p>───── ( <span class="math inline">\(ExistsI\)</span> )<br />
<span class="math inline">\(\ \ \ \exists x . \phi\)</span></p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode idris"><code class="sourceCode idris"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ExistsE</span> <span class="ot">:</span> {ϕ <span class="ot">:</span> <span class="dt">Index</span> <span class="ot">-&gt;</span> <span class="dt">Formula</span>} <span class="ot">-&gt;</span> {Ψ <span class="ot">:</span> <span class="dt">Formula</span>}  <span class="ot">-&gt;</span> <span class="dt">T</span> (<span class="dt">Exists</span> ϕ) <span class="ot">-&gt;</span> (<span class="dt">T</span> (<span class="dt">Exists</span> ϕ) <span class="ot">-&gt;</span> <span class="dt">T</span> Ψ) <span class="ot">-&gt;</span> <span class="dt">T</span> Ψ</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ExistsI</span> <span class="ot">:</span> {ϕ <span class="ot">:</span> <span class="dt">Index</span> <span class="ot">-&gt;</span> <span class="dt">Formula</span>} <span class="ot">-&gt;</span> {t <span class="ot">:</span> <span class="dt">Index</span>} <span class="ot">-&gt;</span> <span class="dt">T</span> (ϕ t) <span class="ot">-&gt;</span> <span class="dt">T</span> (<span class="dt">Exists</span> ϕ)   </span></code></pre></div>
<hr />
<p><span class="math inline">\(\ \forall x. \phi\)</span></p>
<p>───── ( <span class="math inline">\(ForallE\)</span> )<br />
<span class="math inline">\(\ \phi \ t\)</span></p>
<p> </p>
<p><span class="math inline">\(\ \ \phi \ t\)</span></p>
<p>───── ( <span class="math inline">\(ForallI\)</span> )<br />
<span class="math inline">\(\ \ \ \forall x . \phi\)</span></p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode idris"><code class="sourceCode idris"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ForallE</span> <span class="ot">:</span> {ϕ <span class="ot">:</span> <span class="dt">Index</span> <span class="ot">-&gt;</span> <span class="dt">Formula</span>} <span class="ot">-&gt;</span> {t <span class="ot">:</span> <span class="dt">Index</span>} <span class="ot">-&gt;</span> <span class="dt">T</span> (<span class="dt">Forall</span> ϕ) <span class="ot">-&gt;</span> <span class="dt">T</span> (ϕ t)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ForallI</span> <span class="ot">:</span> {ϕ <span class="ot">:</span> <span class="dt">Index</span> <span class="ot">-&gt;</span> <span class="dt">Formula</span>} <span class="ot">-&gt;</span> {t <span class="ot">:</span> <span class="dt">Index</span>} <span class="ot">-&gt;</span> <span class="dt">T</span> (ϕ t) <span class="ot">-&gt;</span> <span class="dt">T</span> (<span class="dt">Forall</span> ϕ)</span></code></pre></div>
<h3 id="proofs-examples-1">Proofs examples</h3>
<p>Let’s prove some theorems<br />
<span class="math inline">\((\forall x . x = x)\)</span></p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode idris"><code class="sourceCode idris"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="fu">proof1</span> <span class="ot">:</span> <span class="dt">T</span> (<span class="dt">Forall</span> (<span class="fu">\</span>x <span class="ot">:</span> <span class="dt">Index</span> <span class="ot">=&gt;</span> x <span class="fu">`Equal`</span> x))</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>proof1 <span class="fu">=</span> <span class="dt">ForallI</span> (<span class="dt">Equal0</span> {x})</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> <span class="fu">x</span> <span class="ot">:</span> <span class="dt">Index</span></span></code></pre></div>
<p><span class="math inline">\((\forall x . \phi \Rightarrow \exists x .
\phi )\)</span></p>
<p>First we prove the lemma <span class="math inline">\((\forall x .
\phi \vdash \exists x . \phi )\)</span></p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode idris"><code class="sourceCode idris"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="fu">lemma</span> <span class="ot">:</span> {ϕ <span class="ot">:</span> <span class="dt">Index</span> <span class="ot">-&gt;</span> <span class="dt">Formula</span>} <span class="ot">-&gt;</span> <span class="dt">T</span> (<span class="dt">Forall</span> ϕ) <span class="ot">-&gt;</span> <span class="dt">T</span> (<span class="dt">Exists</span> ϕ)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>lemma p <span class="fu">=</span> <span class="dt">ExistsI</span> <span class="fu">$</span> <span class="dt">ForallE</span> {ϕ} {t} p</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">t</span> <span class="ot">:</span> <span class="dt">Index</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    t <span class="fu">=</span> <span class="dt">Choice</span> ϕ</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a><span class="fu">proof2</span> <span class="ot">:</span> {ϕ <span class="ot">:</span> <span class="dt">Index</span> <span class="ot">-&gt;</span> <span class="dt">Formula</span>} <span class="ot">-&gt;</span> <span class="dt">T</span> ((<span class="dt">Forall</span> ϕ) <span class="fu">`Imp`</span> (<span class="dt">Exists</span> ϕ))</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>proof2 <span class="fu">=</span> <span class="dt">ImpI</span> lemma</span></code></pre></div>
<p>Once again, this would be the proofs using just Curry-Howard.</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode idris"><code class="sourceCode idris"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- ∀ x . x = x </span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="fu">proof1</span> <span class="ot">:</span> (x<span class="ot">:</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> x <span class="fu">=</span> x</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>proof1 x <span class="fu">=</span> <span class="dt">Refl</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="co">--  ∀x.Φ ⇒ ∃x.Φ</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="fu">proof2</span> <span class="ot">:</span> {x <span class="ot">:</span> <span class="dt">Type</span>} <span class="ot">-&gt;</span> {<span class="dt">P</span> <span class="ot">:</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>} <span class="ot">-&gt;</span> ( (x) <span class="ot">-&gt;</span> <span class="dt">P</span> x ) <span class="ot">-&gt;</span> (x <span class="fu">**</span> <span class="dt">P</span> x)</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>proof2 f <span class="fu">=</span> (x <span class="fu">**</span> (f y))</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> <span class="fu">y</span> <span class="ot">:</span> x</span></code></pre></div>
<h1 id="whats-the-point-of-this-should-i-use-agda-or-idris">Whats the
point of this? Should i use Agda or Idris?</h1>
<p>Implementing a formal system this way is really fast, specially
because we don’t have to mechanize all the machinery needed for handling
binders. We just let the underlying metalanguage (Idris, Agda, whatever)
take care of it so we don’t worry.</p>
<p>I’ve used Idris here because i’ve learned it first, is really easy if
you know Haskell already. Both are awesome languages, and really
alike.<br />
I would say that using Agda as a theorem prover is better, also it has
mixfix operators so defining the abstract syntax of formal systems is
better and leads to more readable code.</p>
<p>The adventage of Idris is that it has more general programming
capabilities, it’s just like a dependently typed Haskell. Imagine you
want to make a theorem prover of FOL using this approach, even you want
it with a GUI and a DSL : you can use a library of parser combinators
and and some GUI library for this. You can even then transpile it to
Javascript.<br />
Doing this in Agda is also capable but you would have to interface it
with Haskell for using their libraries.</p>
<h1 id="code">Code</h1>
<p>See the <a
href="https://github.com/domandlj/Judgments-as-types">repo</a> files
<code>pl.idr</code> and <code>fol.idr</code>, they typecheck.</p>
<h1 id="bibliography">Bibliography</h1>
<ul>
<li>Avron, Arnon &amp; Honsell, Furio &amp; Mason, Ian. (1996). An
Overview of the Edinburgh Logical Framework.
10.1007/978-1-4612-3658-0_8.</li>
</ul>
</body>
</html>
